diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 14a622a68fad..3d514515fd5f 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -183,6 +183,10 @@ import java.util.Objects;
 import java.util.TimeZone;
 import java.util.concurrent.Executor;
 
+//++++++++++++++++++++++++++++
+import cn.unpack.Unpacker;
+//++++++++++++++++++++++++++++
+
 final class RemoteServiceException extends AndroidRuntimeException {
     public RemoteServiceException(String msg) {
         super(msg);
@@ -5895,6 +5899,10 @@ public final class ActivityThread extends ClientTransactionHandler {
 
             mInitialApplication = app;
 
+            //++++++++++++++++++++++++++++
+            Unpacker.unpack();
+            //++++++++++++++++++++++++++++
+
             // don't bring up providers in restricted mode; they may depend on the
             // app's custom Application class
             if (!data.restrictedBackupMode) {
diff --git a/core/java/cn/unpack/Unpacker.java b/core/java/cn/unpack/Unpacker.java
new file mode 100644
index 000000000000..847458cdec8f
--- /dev/null
+++ b/core/java/cn/unpack/Unpacker.java
@@ -0,0 +1,61 @@
+package cn.unpack;
+import android.app.ActivityThread;
+import android.os.Looper;
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.File;
+
+public class Unpacker {
+    public static String UNPACK_CONFIG = "/data/local/tmp/unpacker.config";
+    public static int UNPACK_INTERVAL = 10 * 1000;
+    public static Thread unpackerThread = null;
+
+    public static boolean shouldUnpack() {
+        boolean should_unpack = false;
+        String processName = ActivityThread.currentProcessName();
+        BufferedReader br = null;
+        try {
+            br = new BufferedReader(new FileReader(UNPACK_CONFIG));
+            String line;
+            while ((line = br.readLine()) != null) {
+                if (line.equals(processName)) {
+                    should_unpack = true;
+                    break;
+                }
+            }
+            br.close();
+        }
+        catch (Exception ignored) {
+            
+        }
+        return should_unpack;
+    }
+
+    public static void unpack() {
+        if (Unpacker.unpackerThread != null) {
+            return;
+        }
+
+        if (!shouldUnpack()) {
+            return;
+        }
+        
+        //开启线程调用
+        Unpacker.unpackerThread = new Thread() {
+            @Override public void run() {
+                while (true) {
+                    try {
+                        Thread.sleep(UNPACK_INTERVAL);
+                    }
+                    catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    Unpacker.unpackNative();
+                }
+            }
+        };
+        Unpacker.unpackerThread.start();
+    }
+
+    public static native void unpackNative();
+}
